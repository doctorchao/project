设备宽度 就是说设备css像素 也就是逻辑像素
设计稿宽度 一般说某款机器屏幕宽度 就是其物理像素  
设计稿元素尺寸 在设计稿中自定义
css = 设备宽度/设计稿宽度*设计稿元素尺寸 
设备屏宽就是设备css像素

iphone6 设备物理像素 750*1334  逻辑css像素 375*667
css = 设备宽度/设计稿宽度*设计稿元素尺寸
设计稿是750*1334  设计稿上标注一个元素的大小是100px;

这么个东西，我要写iphone6上。width?
50px。

android 的设备，他的屏宽又不是375怎么办？
假设android 的设备屏宽是800px;
800/750 * 100px。

X*rem = 设备宽度/设计稿宽度*设计稿元素尺寸

rem = {设备宽度/设计稿宽度*设计稿元素尺寸}/X;

网易的方案，假设X = 设计稿元素尺寸的0.01;

rem = 设备宽度 / 设计稿宽度 * 100

以750的设计稿为例。

px是固定的像素，一旦设置了就无法因为适应页面大小而改变。
em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。
对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。
rem中的r意思是root（根源），这也就不难理解了。

子元素字体大小的em是相对于父元素字体大小
元素的width/height/padding/margin用em的话是相对于该元素的font-size

“em”是一个相对的大小，我们可以这样来设置1em，0.5em，1.5em等，而且“em”还可以指定到
小数点后三位，比如“1.365em”。而其中“相对”的意思是：
相对的计算必然会一个参考物，那么这里相对所指的是相对于元素父元素的font-size。

比如说：如果在一个<div>设置字体大小为“16px”，此时这个<div>的后代元素是将继承他的字体大小，
除非重新在其后代元素中进行过显示的设置。此时，如果你将其子元素的字体大小设置为“0.75em”，
那么其字体大小计算出来后就相当于“0.75 X 16px = 12px”；

如果用户通过浏览器的UI控件改变了文字的大小，那么我们整个页面也会进行放大（或缩小），
不至于用户改变了浏览器的字体后会致使整个页面崩溃（我想这种现像大家都有碰到过，
不信你就试试你自己制作过的项目，你会觉得很恐怖）。

在CSS中，“em”实际上是一个垂直测量。一个em等于任何字体中的字母所需要的垂直空间，
而和它所占据的水平空间没有任何的关系，因此：
如果字体大小是16px，那么1em=16px。

  Chrome浏览器默认最小字体为12px  往小设置也是显示12px

 <!-- html标准字体大小16px -->

 em 相对父元素font-size，元素块内宽、高等em 基于本身font-size
 rem 均是相对于html： font-size

 body是html 子元素  两者font-size作用区域相同  但body可覆盖html